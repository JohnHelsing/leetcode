//给定一个整数数组 A，你可以从某一起始索引出发，跳跃一定次数。
// 在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。
//
// 你可以按以下方式从索引 i 向后跳转到索引 j（其中 i < j）： 
//
// 
// 在进行奇数跳跃时（如，第 1，3，5... 次跳跃），
// 你将会跳到索引 j，使得 A[i] <= A[j]，A[j] 是可能的最小值。如果存在多个这样的索引j，
// 你只能跳到满足要求的最小索引 j 上。
// 在进行偶数跳跃时（如，第 2，4，6... 次跳跃），你将会跳到索引 j，
// 使得 A[i] >= A[j]，A[j] 是可能的最大值。如果存在多个这样的索引j，
// 你只能跳到满足要求的最小索引 j 上。
// （对于某些索引 i，可能无法进行合乎要求的跳跃。） 
// 
//
// 如果从某一索引开始跳跃一定次数（可能是 0 次或多次），
// 就可以到达数组的末尾（索引 A.length - 1），那么该索引就会被认为是好的起始索引。
//
// 返回好的起始索引的数量。 
//
// 
//
// 示例 1： 
//
// 输入：[10,13,12,14,15]
//输出：2
//解释： 
//从起始索引 i = 0 出发，我们可以跳到 i = 2，
// （因为 A[2] 是 A[1]，A[2]，A[3]，A[4] 中大于或等于 A[0] 的最小值），然后我们就无法继续跳下去了。
//从起始索引 i = 1 和 i = 2 出发，我们可以跳到 i = 3，然后我们就无法继续跳下去了。
//从起始索引 i = 3 出发，我们可以跳到 i = 4，到达数组末尾。
//从起始索引 i = 4 出发，我们已经到达数组末尾。
//总之，我们可以从 2 个不同的起始索引（i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。
// 
//
// 示例 2： 
//
// 输入：[2,3,1,1,4]
//输出：3
//解释：
//从起始索引 i=0 出发，我们依次可以跳到 i = 1，i = 2，i = 3：
//
//在我们的第一次跳跃（奇数）中，我们先跳到 i = 1，因为 A[1] 是（A[1]，A[2]，A[3]，A[4]）中大于或等于 A[0] 的最小值。
//
//在我们的第二次跳跃（偶数）中，我们从 i = 1 跳到 i = 2，因为 A[2] 是（A[2]，A[3]，A[4]）中小于或等于 A[1] 的最大值。A[
//3] 也是最大的值，但 2 是一个较小的索引，所以我们只能跳到 i = 2，而不能跳到 i = 3。
//
//在我们的第三次跳跃（奇数）中，我们从 i = 2 跳到 i = 3，因为 A[3] 是（A[3]，A[4]）中大于或等于 A[2] 的最小值。
//
//我们不能从 i = 3 跳到 i = 4，所以起始索引 i = 0 不是好的起始索引。
//
//类似地，我们可以推断：
//从起始索引 i = 1 出发， 我们跳到 i = 4，这样我们就到达数组末尾。
//从起始索引 i = 2 出发， 我们跳到 i = 3，然后我们就不能再跳了。
//从起始索引 i = 3 出发， 我们跳到 i = 4，这样我们就到达数组末尾。
//从起始索引 i = 4 出发，我们已经到达数组末尾。
//总之，我们可以从 3 个不同的起始索引（i = 1, i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。
// 
//
// 示例 3： 
//
// 输入：[5,1,3,4,2]
//输出：3
//解释： 
//我们可以从起始索引 1，2，4 出发到达数组末尾。
// 
//
// 
//
// 提示： 
//
// 
// 1 <= A.length <= 20000 
// 0 <= A[i] < 100000 
// 
// Related Topics 栈 数组 动态规划 有序集合 单调栈 👍 136 👎 0

package com.helsing.leetcode.editor.cn;

import java.util.TreeMap;

public class Q0975_OddEvenJump {

    public static void main(String[] args) {
        Solution solution = new Solution();
    }

    static
            //leetcode submit region begin(Prohibit modification and deletion)
    class Solution {
        public int oddEvenJumps(int[] arr) {
            int len = arr.length;
            // 距离当前数值最近的数值 & 下标 (重复中最近)
            TreeMap<Integer, Integer> map = new TreeMap<>();
            // 最后一个值入备选集合
            map.put(arr[len - 1], len - 1);
            // 0 从当前位置i,奇数步出发是否可以抵达最后一个格子 , 1是偶数步
            Boolean[][] dp = new Boolean[len][2];
            // 最后一个格子,抵达则达成条件
            dp[len - 1][0] = true;
            // 最后一个格子,抵达则达成条件
            dp[len - 1][1] = true;
            int ans = 1;
            // 倒着走,从后往前走
            for (int index = len - 2; index >= 0; index--) {
                // 找A[i] <= A[j],当前奇数步出发,是否有后续能接纳的位置
                Integer ceil = map.ceilingKey(arr[index]);
                // A[i] >= A[j],当前偶数步出发,是否有后续能接纳的位置
                Integer floor = map.floorKey(arr[index]);
                // ==null,后续没有格子,当前奇数步出发,不能抵达.否则取决于后续偶数步是否能抵达
                dp[index][0] = ceil == null ? false : dp[map.get(ceil)][1];
                // 同上,给前面奇数步出发垫步用的,对于当前点没用.
                dp[index][1] = floor == null ? false : dp[map.get(floor)][0];
                // 起脚就是奇数,判断当前点,作为首发出发是否能抵达
                if (dp[index][0]) {
                    // 能就多一种方案
                    ans++;
                }
                // 当前点加入备选列表,给index--用.只能在当前阶段处理后加入,否则被当成后面的点,就错了.
                map.put(arr[index], index);
            }
            return ans;
        }
    }
//leetcode submit region end(Prohibit modification and deletion)

}
